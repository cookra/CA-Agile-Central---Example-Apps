<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!-- Copyright (c) 2002-2011  Rally Software Development Corp. All rights reserved. -->
<head>
<title>Release Dashboard</title>
<meta name="Name" content="Mashup: Release Dashboard"/>
<meta name="Version" content="2014.05.28"/>
<meta name="Vendor" content="Rally Software"/>
<link rel="stylesheet" type="text/css" href="/slm/css/rally/core.css" charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="/slm/css/slm.css" charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="/slm/js-lib/dojo/1.3.1/dijit/themes/nihilo/nihilo.css">

<script type="text/javascript" description="CSS Selection">
    var fileref = document.createElement("link");
    fileref.setAttribute("rel", "stylesheet");
    fileref.setAttribute("type", "text/css");
    if ('__MODE__' == 'widget' || '__MODE__' == 'panel') {
        fileref.setAttribute("href", "/slm/mashup/1.15/css/widget.css");
    } else {
        fileref.setAttribute("href", "/slm/mashup/1.15/css/mashup.css");
    }
    document.getElementsByTagName("head")[0].appendChild(fileref);
</script>

<script type="text/javascript" src="/slm/js-lib/dojo/rally-1.3.1/dojo/dojo.js"></script>
<script type="text/javascript">
    dojo.require('dijit.TitlePane');
</script>
<script type="text/javascript" src="/slm/js/help.js"></script>
<script type="text/javascript" src="/slm/js/slm.js"></script>
<script type="text/javascript" src="/apps/1.33/lib/ejsc/EJSChart.js"></script>
<script type="text/javascript" src="/slm/mashup/1.15/js/utilities.js"></script>
<script type="text/javascript" src="/slm/mashup/1.15/js/dropdown.js"></script>
<script type="text/javascript" src="/slm/mashup/1.15/js/batch-toolkit.js"></script>

<script type="text/javascript">
/*!
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 Pie.js
 */

var RALLY = RALLY || {};

// Careful!! TypeDefinition's have SPACES in the names! See the below hash.
var fieldNameByArtifact = {
    "Hierarchical Requirement": "Schedule State",
    "Defect": "State",
    "Test Case": "Last Verdict"
}

RALLY.Mashup = RALLY.Mashup || {};

Array.prototype.findIndex = function(value) {
    for (var i = 0; i < this.length; i++) {
        // use === to check for Matches. ie., identical (===), ;
        if (this[i] == value) {
            return i;
        }
    }
    return null;
};

RALLY.Mashup.Pie = function(batchToolkit, config, callback) {

    // --- Private variables --------------------------------------

    var that = this;
    var pieData = {};
    var healthInfo = null;

    function render(label, states, values, width, height, target) {
        var data = [];
        var colors_for_states = [];
        var legend;

        target.innerHtml = null;

        pieData = {"states" : states, "results": values};

        for (var i = 0; i < states.length; i++) {
            data.push([parseFloat(values[i]), states[i]]);
            colors_for_states.push(states[i]);
        }

        if (data.length === 0){
            document.getElementById(target).innerHTML = 'No Data';
            document.getElementById(target).style.fontSize = '10px';
        } else {
            colors_for_states = RALLY.Mashup.Pie.getColors(colors_for_states);

            var theChart = new EJSC.Chart(target, {
                show_legend: false,
                show_titlebar: false
            });

            theChart.onShowHint = function(point, series, chart, hint, hoverOrSelect) {
                return '[label]: [x]';
            };

            theChart.addSeries(new EJSC.PieSeries(
                    new EJSC.ArrayDataHandler(data), {
                        defaultColors: colors_for_states.reverse(),
                        position: "center",
                        height: "90%",
                        width: "90%"
                    }
            ));
        }

        callback(config.timeboxStart, config.timeboxEnd, states, values);
    }

    function main() {
        var timeboxName = config.timeboxName;
        var timeboxStart = config.timeboxStart;
        var timeboxEnd = config.timeboxEnd;
        var timeboxType = config.timeboxType;
        var artifactType = config.artifactType;
        var artifactAttribute = config.artifactAttribute;
        var chartDiv = config.chartDiv;
        var projectOid = config.projectOid;
        var workspaceOid = config.workspaceOid;
        var artifactData = config.artifactData;

        var pieWidth, pieHeight;

        if (typeof config.pieWidth !== 'undefined') {
            pieWidth = config.pieWidth;
        } else {
            pieWidth = 250;
        }

        if (typeof config.pieHeight !== 'undefined') {
            pieHeight = config.pieHeight;
        } else {
            pieHeight = 150;
        }

        if (typeof config.allowedValues !== 'undefined') {
            allowedValues = config.allowedValues;
        } else {
            allowedValues = null;
        }

        function showPie(dataConfig) {
            pieDataHandler = new RALLY.Mashup.Pie.Data(batchToolkit, dataConfig);

            function doRender(states, values) {
                render("pie label", states, values, pieWidth, pieHeight, chartDiv);
            }

            if (artifactType === 'ScheduledWork') {
                pieDataHandler.getScheduledWork(doRender);
            } else if (artifactType === 'TestCase') {
                pieDataHandler.getTestCases(doRender);
            } else if (artifactType === 'Defect') {
                pieDataHandler.getDefects(doRender);
            }
        }

        function run() {
            var pieDataHandler;
            var dataConfig = {};
            dataConfig.timeboxType = timeboxType;
            dataConfig.timeboxName = timeboxName;
            dataConfig.timeboxStart = timeboxStart;
            dataConfig.timeboxEnd = timeboxEnd;
            dataConfig.projectOid = projectOid;
            dataConfig.workspaceOid = workspaceOid;
            dataConfig.allowedValues = allowedValues;
            dataConfig.artifactData = artifactData;

            showPie(dataConfig);
        }

        run();
    }

    // --- Public methods -----------------------------------------

    this.getData = function() {
        return pieData;
    };

    this.setData = function(data) {
        pieData = data;
    };

    this.draw = function() {
        var results = {};
        for (var i = 0; i < pieData.states.length; i++) {
            results[i] = pieData.results[i];
        }
        render(null, pieData.states, results, config.pieWidth, config.pieHeight, config.chartDiv);
    };

    this.display = function() {
        main();
    };

    return that;
};


RALLY.Mashup.Pie.Data = function(batchToolkit, config) {

    // --- Private variables --------------------------------------

    var that = this;
    var allowedValues = {};

    function getAllowedValues(callback) {
        if (typeof allowedValues.scheduleStates === 'undefined') {
            if (config.allowedValues) {
                allowedValues = config.allowedValues;
                callback();
            } else {
                runAllowedValuesQuery(callback);
            }
        } else {
            callback();
        }
    }

    // In this version, this function is replicated below, probably causing this particular version to never be called:
    function runAllowedValuesQuery(callback) {

        var processAllowedValues = function(result) {

            var typeDefsKeys = [];
            var allowedValuesHash = {};
            var allowedValuesStrings = [];

            // Result will come back as a hash: {"errors": [], "warnings": [], "keyNameInQueryConfig":typeDefsObject}
            // We need to loop through the hash fields to grab just the typeDefs key since we don't know which key we were passed, per se
            for (var property in result) {
                if (result.hasOwnProperty(property)) {
                    if ((property !== "errors") && (property !== "warnings")) {
                        allowedValuesHash[property] = [];
                        typeDefsKeys.push(property);
                    }
                }
            }

            for (var i=0; i<typeDefsKeys.length; i++) {
                var typeDefsKey = typeDefsKeys[i];
                var typeDefs = result[typeDefsKey];
                var artifactType = typeDefs[0].Name;
                var objectFieldName = "";

                objectFieldName = fieldNameByArtifact[artifactType];

                var attributes = typeDefs[0].Attributes;
                for (var j=0; j<attributes.length; j++) {
                    var attrName = attributes[j].Name;
                    if (attrName === objectFieldName) {
                        var allowedValues = attributes[j].AllowedValues;
                        allowedValuesStrings = [];
                        for (var k=0; k<allowedValues.length; k++) {
                            allowedValuesStrings.push(allowedValues[k].StringValue);
                        }
                        allowedValuesHash[typeDefsKey] = allowedValuesStrings;
                    }
                }
            }
            return allowedValuesHash;
        };

        var queryArray = [];

        // queryArray[0] = {
        //     key: 'scheduleState',
        //     type: 'Hierarchical Requirement',
        //     attribute: 'Schedule State',
        //     workspace: '/workspace/' + config.workspaceOid
        // };
        // queryArray[1] = {
        //     key: 'testResult',
        //     type: 'Test Case',
        //     attribute: 'Last Verdict',
        //     workspace: '/workspace/' + config.workspaceOid
        // };
        // queryArray[2] = {
        //     key: 'defectState',
        //     type: 'Defect',
        //     attribute: 'State',
        //     workspace: '/workspace/' + config.workspaceOid

        // };

        queryArray[0] = {
          type : 'TypeDefinition',
          key : 'scheduleState',
          fetch: 'Name,Attributes',
          query: '(Name = "Hierarchical Requirement")',
          workspace: '/workspace/' + WORKSPACE_OID
        };
        queryArray[1] = {
            type: 'TypeDefinition',
            key: 'testResult',
            fetch: 'Name,Attributes',
            query: '(Name = "Test Case")',
            workspace: '/workspace/' + WORKSPACE_OID
        };
        queryArray[2] = {
            type: 'TypeDefinition',
            key: 'defectState',
            fetch: 'Name,Attributes',
            query: '(Name = "Defect")',
            workspace: '/workspace/' + WORKSPACE_OID
        };
        try {
            batchToolkit.findAll(queryArray,
                    function(results) {
                        // allowedValues.scheduleStates = removeEmptyValues(results.scheduleState);
                        // allowedValues.testVerdicts = removeEmptyValues(results.testResult);
                        // allowedValues.defectStates = removeEmptyValues(results.defectState);
                        var allowedValuesHash = processAllowedValues(results);
                        allowedValues.scheduleStates = removeEmptyValues(allowedValuesHash.scheduleState);
                        allowedValues.testVerdicts = removeEmptyValues(allowedValuesHash.testResult);
                        allowedValues.defectStates = removeEmptyValues(allowedValuesHash.defectState);
                        callback();
                    }
            );
        }

        catch(err) {
            console.log('error');
            //TODO: Fill this in
        }
    }

    // Takes two data objects and adds their values together. returns a new object with the added values
    function formatObjectContents(data1, data2) {
        for (var x in data1) {
            if (data1.hasOwnProperty(x)) {
                data1[x] = parseInt(data1[x], 10);
            } else {
                console.log('WHY WOULD THIS EVER HAPPEN??')
            }
        }
        return data1;
    }

    function executeQuery(query, callback) {
        //add project here
        for (var i = 0; i < query.length; i++) {
            query[i].project = "/project/" + config.projectOid;
            query[i].workspace = "/workspace/" + config.workspaceOid;
            addScopeSettings(query[i]);
        }
        batchToolkit.find(query, callback);
    }

//TODO: this function is duplicated elsewhere
    function addScopeSettings(query) {
        if (typeof config.scopeUp !== 'undefined') {
            query.projectScopeUp = config.scopeUp;
        }
        if (typeof config.scopeDown !== 'undefined') {
            query.projectScopeDown = config.scopeDown;
        }
    }

    function ensureAllowedValues(allowedArray, states, values) {
        var i,result = {states:[],values:[]};

        for (i = 0; i < allowedArray.length; i++) {
            // for test case results, check for state=null
            if (allowedArray[i] === 'No Result'){
                if (states.findIndex("null") === null) {
                    result.states.push('No Result');
                    result.values.push(0);
                } else {
                    result.states.push('No Result');
                    result.values.push(values[states.findIndex("null")]);
                }
            }

            if (states.findIndex(allowedArray[i]) === null) {
                result.states.push(allowedArray[i]);
                result.values.push(0);
            } else {
                result.states.push(allowedArray[i]);
                result.values.push(values[states.findIndex(allowedArray[i])]);
            }
        }
        return result;
    }

    // Public methods
    this.getScheduledWork = function(callback) {
        function finishPie() {
            var states = [], values = [],tempPieObject = null;
            var result;

            tempPieObject = config.artifactData;

            for (var x in tempPieObject) {
                if (tempPieObject.hasOwnProperty(x)) {
                    states.push(x);
                    values.push(tempPieObject[x]);
                }
            }
            result = ensureAllowedValues(allowedValues.scheduleStates, states, values);
            callback(result.states, result.values);
        }

        // Don't run FinishPie if there is no data.
        // - Shouldn't get here if there is no data...
        getAllowedValues(finishPie);
    };

    this.getDefects = function(callback) {

        function finishPie() {
            var states = [], values = [],tempPieObject = null;
            var result;

            tempPieObject = config.artifactData;

            for (var x in tempPieObject) {
                if (tempPieObject.hasOwnProperty(x)) {
                    states.push(x);
                    values.push(tempPieObject[x]);
                }
            }
            result = ensureAllowedValues(allowedValues.defectStates, states, values);
            callback(result.states, result.values);
        }

        getAllowedValues(finishPie);
    };

    this.getTestCases = function(callback) {

        function finishPie() {
            var states = [], values = [],tempPieObject = null;
            var result;

            tempPieObject = config.artifactData;

            for (var x in tempPieObject) {
                if (tempPieObject.hasOwnProperty(x)) {
                    states.push(x);
                    values.push(tempPieObject[x]);
                }
            }
            result = ensureAllowedValues(allowedValues.testVerdicts, states, values);
            callback(result.states, result.values);
        }

        getAllowedValues(finishPie);
    };

    return that;
};

RALLY.Mashup.Pie.getColors = function(states) {
    var red = '#F47168';
    var dark_red = "#EF3F35";
    var orange = '#E57E3A';
    var blue = '#5C9ACB';
    var green = '#6AB17D';
    var dark_green = '#3A874F';
    var yellow = '#E5D038';
    var light_green = '#B2E3B6';
    var gray = '#E0E0E0';
    var white = '#FFFFFF';
    var very_light_gray = '#F0F0F0';
    var light_gray = '#E8E8E8';

    // color_fillers array used to assign colors to non-standard statuses
    var color_fillers = ['#ACACAC', '#D9AF4B', '#B5D8EB', '#196C89',
        '#747474', '#FCB5B1', '#A0A87F', '#FBDE98',
        '#FFF8DC', '#F08080', '#FFEBCD', '#FFA07A',
        '#FFE4C4', '#FFB6C1', '#A0522D', '#BC8F8F', '#F4A460', '#66CDAA',
        '#DAA520', '#B8860B', '#CD853F', '#D2691E', '#8B4513', '#800000',
        '#FFDEAD', '#FF7F50', '#F5DEB3', '#9370DB', '#DEB887', '#483D8B',
        '#D2B48C', '#808000', '#A52A2A'];

    // map state to color: add states as needed
    var color_map = {
        'Defined': orange,
        'In-Progress': blue,
        'Completed': light_green,
        'Accepted': green,
        'Blocked': yellow,
        'Error': orange,
        'Fail': dark_red,
        'Pass': green,
        'Inconclusive': gray,
        'Submitted': gray,
        'Open': dark_red,
        'Fixed': orange,
        'Closed': green,
        'null' : very_light_gray,
        'No Result' : very_light_gray
    };

    var colors = [];

    for (var i = 0; i < states.length; i++) {
        if (i === 0 && states[1] === "Defined") {
            colors.push(dark_red);
            continue;
        }
        if (color_map[states[i]]) {
            colors.push(color_map[states[i]]);
        } else {
            colors.push(color_fillers.pop());
        }
        if (states[i] == 'Accepted' && i === states.length-2) {
            colors.push(dark_green);
            break;
        }
    }
    return colors;
};
</script>

<script type="text/javascript" src="/slm/mashup/1.15/js/legend.js"></script>


<script type="text/javascript">
//---compress---/
/*!
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 SuperCustomizableUtilities.js
 */

function addDaysToDate(date, days) {
    return (date.getTime() + RALLY.Mashup.Utilities.convertDaysToMilliseconds(days));
}

function findDateForDay(start, nthWorkDay) {
    //Finds the date corresponding to the nth work day
    //starting at some beginning date
    var aDate, workDaysFound, startDate, nthDay;
    startDate = RALLY.Mashup.Utilities.convertIsoDateOnly(start);

    nthDay = Math.round(nthWorkDay);
    if (nthDay <= 0) {
        return startDate;
    }
    aDate = RALLY.Mashup.Utilities.convertIsoDateOnly(start);
    workDaysFound = 0;
    while (workDaysFound < nthDay) {
        if (RALLY.Mashup.Utilities.isWorkDay(aDate)) {
            workDaysFound = workDaysFound + 1;
            if (workDaysFound === nthDay) {
                return aDate;
            }
        }
        aDate.setTime(addDaysToDate(aDate, 1));
    }
    return null;
}

function aggregateFlowDataPerDay(theData) {
    var i, firstDataDay, lastDataDay;

    firstDataDay = getFirstDataDay(theData.inProgressData);
    lastDataDay = theData.categories.length-1;

    function getFirstDataDay(data) {
        for (i = 0; i < data.length; i++) {
            if (data[i][1] != 0) {
                return i;
            }
        }
        return 0;
    }

    var chartData = {
        "firstDataDay" : firstDataDay,
        "lastDataDay" : lastDataDay,

        "categories" : theData.categories,
        "acceptedData" : theData.acceptedData
    };

    if (MASHUP_TYPE === RALLY.Mashup.RELEASE) {
        chartData.definedData = theData.definedData;
        chartData.completedData = theData.completedData;
        chartData.beforeStateData = theData.beforeStateData;
        chartData.afterStateData = theData.afterStateData;
        chartData.inProgressData = theData.inProgressData;
    } else if (MASHUP_TYPE === RALLY.Mashup.ITERATION) {
        chartData.todoData = theData.todoData;
        chartData.idealData = theData.idealData;
    }

    return chartData;
}
/*!
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 SuperCustomizableChart.js
 */

var RALLY = RALLY || {};

RALLY.Mashup = RALLY.Mashup || {};

RALLY.Mashup.SuperCustomizableChart = function(batchToolkit, timeboxOidList, timeboxName, timeboxStart, timeboxEnd, mashupType, initialConfig, chartDiv, tableDiv, projectOid, callback) {

    // --- Constants ----------------------------------------------
    var DEFINED_STATE = 'Defined';
    var BEFORE_STATE = 'Idea';
    var INPROGRESS_STATE = 'In-Progress';
    var COMPLETED_STATE = 'Completed';
    var ACCEPTED_STATE = 'Accepted';
    var AFTER_STATE = 'Released';

    var SERIES_PADDING = 3;

    // --- Private variables --------------------------------------

    var that = this;
    var burndownData = {};
    var theChart;
    var dSeries, iSeries, cSeries, aSeries, bSeries, fSeries, theStack;
    var config = {
        ChartType: 'stacked-bar', Units: 'story',
        DefinedVisible: true, InProgressVisible: true,
        CompletedVisible: true, AcceptedVisible: true,
        DefinedColor: '#E57E3A', InProgressColor: '#5C9ACB',
        CompletedColor: '#B2E3B6', AcceptedColor: '#6AB17D',
        BeforeStateColor: '#EF3F35', BeforeStateVisible: true, BeforeStateTrend: false,
        AfterStateColor: '#3A874F', AfterStateVisible: true, AfterStateTrend: false,
        DefinedTrend: false, InProgressTrend: false,
        CompletedTrend: false, AcceptedTrend: false,
        BurndownIdealVisible: false, BurndownIdealColor: '#BBBBBB',
        BurnupIdealVisible: false, BurnupIdealColor: '#BBBBBB', TableVisible: false,
        LeftAxisLabelVisible: true, BottomAxisLabelVisible: true, RightAxisLabelVisible: true,
        LeftAxisVisible: true, BottomAxisVisible: true, RightAxisVisible: true,
        scopeUp: false, scopeDown: true
    };
    var workspaceUnits = [];

    // --- Private methods ----------------------------------------

    //Called after all queries and charts are done
    function wrapup() {
        if (typeof callback !== 'undefined') {
            callback(chartDiv); //caller-supplied callback
        }
    }

    function addScopeSettings(query) {
        if (typeof config.scopeUp !== 'undefined') {
            query.projectScopeUp = config.scopeUp;
        }
        if (typeof config.scopeDown !== 'undefined') {
            query.projectScopeDown = config.scopeDown;
        }
    }

    function applyConfig(overrides) {
        for (var property in overrides) {
            if (overrides.hasOwnProperty(property)) {
                config[property] = overrides[property];
            }
        }
    }

    function getStartFieldName() {
        if (mashupType === RALLY.Mashup.ITERATION) {
            return "StartDate";
        } else {
            return "ReleaseStartDate";
        }
    }

    function getEndFieldName() {
        if (mashupType === RALLY.Mashup.ITERATION) {
            return "EndDate";
        } else {
            return "ReleaseDate";
        }
    }

    function formatDateForChart(jsDate) {
        return (jsDate.getMonth()+1) + "/" + jsDate.getDate();
    }

    function buildGroupedBarSeries(title, data, color, trend, axis) {
        if (typeof axis === 'undefined' || axis === null) {
            axis = "left";
        }
        var series = new EJSC.BarSeries(
                new EJSC.ArrayDataHandler(data), {
                    y_axis: axis,
                    padding: {
                        x_axis_min: SERIES_PADDING,
                        x_axis_max: SERIES_PADDING,
                        y_axis_min: SERIES_PADDING,
                        y_axis_max: SERIES_PADDING
                    }
                });
        series.title = title;
        series.color = color;
        series.opacity = 100;
        series.lineWidth = 1;
        theChart.addSeries(series);

        if (trend && data.length > 1) {
            var trendSeries = new EJSC.TrendSeries(
                    series, "linear");
            trendSeries.lineWidth = 1;
            trendSeries.color = series.color;
            trendSeries.opacity = 100;
            theChart.addSeries(trendSeries);
        }
        return series;
    }

    function buildIdealSeries(type, title, data) {
        var series;
        if (config[type + 'Visible']) {
            if (config.ChartType === 'burndown' && type === 'BurnupIdeal') {
                series = new EJSC.LineSeries(
                        new EJSC.ArrayDataHandler(data), { y_axis: 'right' });
            } else {
                series = new EJSC.LineSeries(
                        new EJSC.ArrayDataHandler(data));
            }
            series.title = title;
            series.color = config[type + 'Color'];
            series.lineWidth = 3;
            series.opacity = 100;
            theChart.addSeries(series);
            return series;
        } else {
            return null;
        }
    }

    function buildStackedBarSeries(stack, title, data, color, trend) {
        var series = new EJSC.BarSeries(
                new EJSC.ArrayDataHandler(data),
                {
                    groupedBars: false
                }
        );
        series.title = title;
        series.color = color;
        series.lineWidth = 1;
        series.opacity = 100;
        stack.addSeries(series);

        if (trend && data.length > 1) {
            var trendSeries = new EJSC.TrendSeries(
                    series, "linear");
            trendSeries.lineWidth = 1;
            trendSeries.color = series.color;
            trendSeries.opacity = 100;
            theChart.addSeries(trendSeries);
        }

        return series;
    }

    function buildBurndownBars(data) {
        theStack = theChart.addSeries(new EJSC.StackedBarSeries({
            intervalOffset: 0.7,
            padding: {
                x_axis_min: SERIES_PADDING,
                x_axis_max: SERIES_PADDING,
                y_axis_min: SERIES_PADDING,
                y_axis_max: SERIES_PADDING
            }
        }));

        if (MASHUP_TYPE === RALLY.Mashup.RELEASE) {
            if (config.BeforeStateVisible) {
                bSeries = buildStackedBarSeries(theStack, BEFORE_STATE,
                        data.beforeStateData, config.BeforeStateColor, config.BeforeStateTrend);
            }
            if (config.DefinedVisible) {
                dSeries = buildStackedBarSeries(theStack, DEFINED_STATE,
                        data.definedData, config.DefinedColor, config.DefinedTrend);
            }
            if (config.InProgressVisible) {
                iSeries = buildStackedBarSeries(theStack, INPROGRESS_STATE,
                        data.inProgressData, config.InProgressColor, config.InProgressTrend);
            }
            if (config.CompletedVisible) {
                cSeries = buildStackedBarSeries(theStack, COMPLETED_STATE,
                        data.completedData, config.CompletedColor, config.CompletedTrend);
            }
            if (config.AcceptedVisible) {
                aSeries = buildGroupedBarSeries(ACCEPTED_STATE,
                        data.acceptedData, config.AcceptedColor, config.AcceptedTrend, "right");
            }
            if (config.AfterStateVisible) {
                fSeries = buildGroupedBarSeries(AFTER_STATE,
                        data.afterStateData, config.AfterStateColor, config.AfterStateTrend, "right");
            }
        } else if (MASHUP_TYPE === RALLY.Mashup.ITERATION) {
            // stuff
        }
    }

    function calculateTotal(chartData, dayNumber) {
        var total;

        if (typeof dayNumber === "undefined") {
            total = 0;
        } else {
            total = chartData.acceptedData[dayNumber][1] +
                    chartData.definedData[dayNumber][1] +
                    chartData.completedData[dayNumber][1] +
                    chartData.inProgressData[dayNumber][1];
            if (config.BeforeStateVisible) {
                total += chartData.beforeStateData[dayNumber][1];
            }
            if (config.AfterStateVisible) {
                total += chartData.afterStateData[dayNumber][1];
            }
        }

        return total;
    }

    function calculateAcceptedTotal(chartData, dayNumber) {
        var total = chartData.acceptedData[dayNumber][1];

        if (config.AfterStateVisible) {
            total += chartData.afterStateData[dayNumber][1];
        }

        return total;
    }

    function calculateToDoTotal(chartData, dayNumber) {
        var total = chartData.inProgressData[dayNumber][1] +
                chartData.completedData[dayNumber][1] +
                chartData.definedData[dayNumber][1];

        if (config.BeforeStateVisible) {
            total += chartData.beforeStateData[dayNumber][1];
        }

        return total;
    }

    function calculateBurndownValue(chartData) {
        return calculateTotal(chartData, chartData.firstDataDay);
    }

    function calculateBurnupValue(chartData) {

        return calculateTotal(chartData, chartData.firstDataDay);
    }

    function calculateAxisEndpoints(chartData) {
        var left = 0, right = 0;
        for (var i = chartData.firstDataDay; i <= chartData.lastDataDay; i++) {
            if (config.ChartType === 'burndown') {
                left = Math.max(left, calculateToDoTotal(chartData, i));
                right = Math.max(right, calculateAcceptedTotal(chartData, i));
            } else {
                left = Math.max(left, calculateTotal(chartData, i));
                right = left;
            }
        }
        if (left < 0.01) {
            left = 1.0;
        }
        if (right < 0.01) {
            right = 1.0;
        }
        return [left, right];
    }

    function drawChart(chartData) {
        var idealData;
        var totalForBurndown, totalForBurnup;
        var idealSeries1, idealTitle1;

        var axisEndpoints, divWidth;
        var smallChartWidth = 300;

        dateList = chartData.categories;

        var axis_bottom_end = dateList.length - 1;

        totalForBurndown = calculateBurndownValue(chartData);
        totalForBurnup = calculateBurnupValue(chartData);
        axisEndpoints = calculateAxisEndpoints(chartData);

        var endDate = dateList[dateList.length-1];

        document.getElementById(chartDiv).style.visibility = "visible";

        // Custom formatter translates x values of 0..n to dates
        var CustomDateFormatter = function() {
            EJSC.Formatter.__extendTo(this);
            this.format = function(value) {
                if (Math.round(value) !== value) {
                    return "";
                }
                if (value >= 0 && value < dateList.length) {
                    // return formatDateForChart(dateList[value]);
                    return dateList[value];
                } else {
                    return formatDateForChart(findDateForDay(timeboxStart, value));
                }
            };
        };

        if (typeof theChart !== 'undefined') {
            theChart.remove();
        }

        theChart = new EJSC.Chart(chartDiv, {
            show_legend: false,
            allow_zoom: false,
            show_titlebar: false,
            axis_bottom: {
                caption:'',
                caption_class: "AxisCaption",
                label_class: "AxisTickLabel",
                size:0,
                min_extreme: 0,
                max_extreme: axis_bottom_end,
                extremes_ticks: true,
                major_ticks: {
                    opacity: 100,
                    min_interval: 3.0,
                    show: true,
                    thickness: 1
                },
                visible: config.BottomAxisVisible
            },
            axis_left: {
                caption: '',
                caption_class: "AxisCaption",
                label_class: "AxisTickLabel",
                size:0,
                min_extreme: 0,
                formatter: new EJSC.NumberFormatter({
                    variable_decimals: 1
                }),
                visible: config.LeftAxisVisible
            },
            axis_right: {
                caption:'',
                caption_class: "AxisCaption",
                label_class: "AxisTickLabel",
                size: 0,
                min_extreme: 0,
                grid: { show: false },
                formatter: new EJSC.NumberFormatter({
                    variable_decimals: 1
                }),
                visible: config.RightAxisVisible
            }
        });

        //Extend bottom axis range slightly for bar charts to prevent clipping
        if (config.ChartType === 'stacked-bar' || config.ChartType === 'grouped-bar' ||
                config.ChartType === 'burndown') {
            theChart.axis_bottom.setExtremes(-0.35, axis_bottom_end + 0.35);
        }

        //Explicitly set y-axis ranges
        theChart.axis_left.setExtremes(0,
                Math.round(Math.max(totalForBurndown, axisEndpoints[0])));
        if (config.ChartType === 'burndown') {
            theChart.axis_right.setExtremes(0,
                    Math.round(Math.max(totalForBurnup, axisEndpoints[1])));
        }

        divWidth = parseInt(document.getElementById(chartDiv).style.width, 10);
        if (isNaN(divWidth)) {
            divWidth = 0;
        }

        if (config.BottomAxisLabelVisible) {
            theChart.axis_bottom.caption = "Date";
            if (divWidth > smallChartWidth) {
                //theChart.axis_bottom.size = Math.round(divWidth * 0.06);
            }
        }

        if (config.LeftAxisLabelVisible) {
            if (divWidth > smallChartWidth) {
                theChart.axis_left.size = Math.round(divWidth * 0.06);
            }
            if (config.Units === 'story') {
                theChart.axis_left.caption = "Plan Estimates";
            } else if (config.Units === 'task') {
                theChart.axis_left.caption = "Task Estimates";
            } else {
                theChart.axis_left.caption = "Task To Do";
            }
        }

        if (config.ChartType === 'burndown') {
            if (divWidth > smallChartWidth) {
                theChart.axis_right.size = Math.round(divWidth * 0.07);
            }
            if (config.RightAxisLabelVisible) {
                theChart.axis_right.caption = "Plan Estimate";
            }
        }

        theChart.axis_bottom.formatter = new CustomDateFormatter();

        theChart.onShowHint = function(point, series, chart, hint, hoverOrSelect) {
            if (series.title.indexOf("Trend") >= 0) {
                return '[series_title]<br/>Value: ' + Math.round(point.y*100)/100;
            } else if (series.title.indexOf("Ideal") >= 0) {
                return '[series_title]<br/>Date: [x]<br/>Value: ' + Math.round(point.y*100)/100;
            } else {
                return '[series_title]<br/>Date: [label]<br/>' + formatUnits(series.title) +
                        ': ' + Math.round(point.y*100)/100;
            }
        };

        if (config.ChartType === 'burndown') {
            buildBurndownBars(chartData);
        } else {
            console.log('Only set up to build a burndown chart!');
        }

        // build ideal series:
        if (MASHUP_TYPE === RALLY.Mashup.ITERATION) {
            idealData = chartData.idealData;

            var idealData1 = [idealData[0],idealData[idealData.length-1]];

            idealTitle1 = 'Ideal Burndown To Do';

            idealSeries1 = buildIdealSeries('BurndownIdeal', idealTitle1, idealData1);
        }
    }

    function formatUnits(seriesTitle) {
        if (config.ChartType === 'burndown' && seriesTitle.indexOf('Accepted') >= 0) {
            //Accepted series is always in plan units for burndown chart
            if (mashupType === RALLY.Mashup.ITERATION) {
                return workspaceUnits.IterationEstimateUnitName;
            } else {
                return workspaceUnits.ReleaseEstimateUnitName;
            }

        } else {
            if (config.Units === 'story') {
                if (mashupType === RALLY.Mashup.ITERATION) {
                    return workspaceUnits.IterationEstimateUnitName;
                } else {
                    return workspaceUnits.ReleaseEstimateUnitName;
                }
            } else {
                return workspaceUnits.TaskUnitName;
            }
        }
    }

    function displayChart() {
        var chartData;
        var today = new Date();

        if (tableDiv !== null) {
            document.getElementById(tableDiv).style.visibility = "hidden";
        }

        if (typeof burndownData.inProgressData === 'undefined' || (
                burndownData.acceptedData.length +
                        burndownData.inProgressData.length +
                        burndownData.definedData.length +
                        burndownData.afterStateData.length +
                        burndownData.beforeStateData.length +
                        burndownData.completedData.length
                ) === 0 ||
                today < RALLY.Mashup.Utilities.convertIsoDateOnly(timeboxStart)){
            document.getElementById(chartDiv).style.visibility = "visible";
            document.getElementById(chartDiv).innerHTML = "No Data";
            wrapup();
        } else {
            chartData = aggregateFlowDataPerDay(burndownData);
            drawChart(chartData);
            wrapup();
        }
    }

    function processMainQuery(mainResults) {
        var emptyArray = [], timeboxOidArray = [], obj = {}, oidList;

        //TODO: is there a more elegant way to build the timeboxOidArray?
        if (timeboxOidList !== null) {
            oidList = timeboxOidList.split(',');
            for (var i = 0; i < oidList.length; i++) {
                obj = {};
                obj['ObjectID'] = oidList[i];
                timeboxOidArray[i] = obj;
            }
        } else {
            timeboxOidArray = mainResults.timeboxOids;
        }

        if (timeboxOidArray.length === 0) {
            return;
        }

        workspaceUnits = mainResults.estimateUnit[0];

        getDataFromA0();

        function getDataFromA0() {
            var releaseOid;

            for (var i = 0; i < timeboxOidArray.length; i++) {
                if (projectOid === timeboxOidArray[i].Project.ObjectID) {
                    releaseOid = timeboxOidArray[i].ObjectID;
                }
            }

            if (typeof releaseOid === 'undefined') {
                console.log('Oids did not match up!');
            }

            var xhrFn = dojo.xhrGet;

            xhrFn({
                url: "/slm/charts/rcfc.sp?releaseOid=" + releaseOid + "&cpoid=" + projectOid,
                handleAs: "xml",
                load: function(xmlDoc) {
                    _createBurndownChartDatafromXML(xmlDoc);
                },
                error: function(error){
                    console.log('error',error);
                }
            });

            function _createBurndownChartDatafromXML(xmlDoc) {
                var beforeStateData, acceptedData, completedData, inProgressData, definedData, afterStateData;

                var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];
                var xmlChartValueText = xmlDoc.getElementsByTagName("chart_value_text")[0];
                var draw = xmlDoc.getElementsByTagName("draw")[0];
                var axis_value = xmlDoc.getElementsByTagName("axis_value")[1];

                var rows = xmlChartData.getElementsByTagName("row");

                var categories = _getStringValues(rows[0].getElementsByTagName("string")); // always categories

                // Order states are returned from the rcfc endpoint:
                // 1) Released / After
                // 2) Accepted
                // 3) Completed
                // 4) InProgress
                // 5) Defined
                // 6) Idea / Before

                var offset = 0,
                        firstState = _getStringValues(rows[1].getElementsByTagName("string"))[0];
                lastState = _getStringValues(rows[rows.length-1].getElementsByTagName("string"))[0];

                if (firstState === "Accepted") {
                    // no after state (released), so remove it:
                    config.AfterStateVisible = false;
                    config.AfterStateTrend = false;
                    offset = -1;
                }
                if (lastState === "Defined"){
                    // no before state (idea), so remove it:
                    config.BeforeStateVisible = false;
                    config.BeforeStateTrend = false;
                }

                acceptedData = _getNumberValues(rows[2 + offset].getElementsByTagName("number"));
                completedData = _getNumberValues(rows[3 + offset].getElementsByTagName("number"));
                inProgressData = _getNumberValues(rows[4 + offset].getElementsByTagName("number"));
                definedData = _getNumberValues(rows[5 + offset].getElementsByTagName("number"));


                if (config.BeforeStateVisible) {
                    beforeStateData = _getNumberValues(rows[6 + offset].getElementsByTagName("number"));
                }
                if (config.AfterStateVisible) {
                    afterStateData = _getNumberValues(rows[1].getElementsByTagName("number"));
                }

                burndownData.categories = categories;
                burndownData.inProgressData = [];
                burndownData.definedData = [];
                burndownData.completedData = [];
                burndownData.acceptedData = [];

                burndownData.beforeStateData = [];
                burndownData.afterStateData = [];

                // There can be empty data in these arrays.
                for (var i = 0; i < categories.length; i++) {
                    burndownData.completedData.push([
                        i,
                        completedData[i],
                        categories[i]
                    ]);
                    burndownData.inProgressData.push([
                        i,
                        inProgressData[i],
                        categories[i]
                    ]);
                    burndownData.definedData.push([
                        i,
                        definedData[i],
                        categories[i]
                    ]);
                    burndownData.acceptedData.push([
                        i,
                        acceptedData[i],
                        categories[i]
                    ]);

                    if (config.BeforeStateVisible) {
                        burndownData.beforeStateData.push([
                            i,
                            beforeStateData[i],
                            categories[i]
                        ]);
                    }
                    if (config.AfterStateVisible) {
                        burndownData.afterStateData.push([
                            i,
                            afterStateData[i],
                            categories[i]
                        ]);
                    }
                }

                displayChart();
            }

            function _getStringValues(elements) {
                var i;
                var strings = [];
                for (i = 0; i < elements.length; i++) {
                    strings.push(_getElementValue(elements[i]));
                }
                return strings;
            }

            function _getNumberValues(elements) {
                var i;
                var numbers = [];
                for (i = 0; i < elements.length; i++) {
                    if(_getElementValue(elements[i])) {
                        numbers.push(_getElementValue(elements[i]).split(' ')[0] * 1);
                    } else {
                        numbers.push(0);
                    }

                }
                return numbers;
            }

            function _getElementValue(element) {
                if (element.textContent !== undefined) {
                    return element.textContent;
                }
                return element.text;
            }
        }
    }

    function runMainQuery() {
        var startDateName = getStartFieldName();
        var endDateName = getEndFieldName();
        var queryArray = [];
        var filter = "((( " + startDateName + " = " + timeboxStart +
            //") AND (" + endDateName + " = " + timeboxEnd + "T23:59:59.000Z" + //temp fix for DE6249
                ") AND (" + endDateName + " = " + timeboxEnd +
                ")) AND (Name = " + '\"' + timeboxName + '\"))';
        queryArray[0] = {
            key: 'timeboxOids',
            type: mashupType,
            fetch: 'ObjectID,Name,project,' + startDateName + ',' + endDateName,
            query: filter,
            order: endDateName + ' desc'
        };
        addScopeSettings(queryArray[0]);
        queryArray[1] = {
            key: 'estimateUnit',
            type: 'WorkspaceConfiguration',
            fetch: 'TaskUnitName,IterationEstimateUnitName,ReleaseEstimateUnitName'
        };
        addScopeSettings(queryArray[1]);

        if (projectOid !== null) {
            queryArray[0].project = '/project/' + projectOid;
        }

        batchToolkit.findAll(queryArray, processMainQuery);
    }

    // --- Public methods -----------------------------------------

    this.display = function() {
        runMainQuery();
    };

    this.redisplay = function(newConfig) {
        applyConfig(newConfig);
        displayChart();
    };

    if (initialConfig !== null) {
        applyConfig(initialConfig);
    }

    return that;
};
//---compress---/
/*!
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 DashboardUtilities.js
 */
function convertMillisecondsToDays(milliseconds) {
    return milliseconds / 86400000;
}

function convertDateStringToDateObject(date_string) {
    date_string = date_string.split('T')[0].split('-');
    var date = new Date();
    date.setFullYear(date_string[0], date_string[1] - 1, date_string[2]);
    return date;
}

function calcWorkDays(start_date, end_date) {
    var daysInRange = convertMillisecondsToDays(end_date - start_date);
    var workDaysInRange = 0;
    var startDay = start_date.getDay();
    var endDay = end_date.getDay();

    if ((startDay > 0) && (startDay < 6)) {
        workDaysInRange += 6 - startDay;
        daysInRange -= 6 - startDay;
    }

    if (endDay == 6) {
        workDaysInRange += 5;
        daysInRange -= 5;
    } else {
        workDaysInRange += endDay;
        daysInRange -= endDay;
    }

    workDaysInRange += Math.floor(daysInRange / 7) * 5;

    return workDaysInRange;
}

function calculateHealth(startDate, endDate, states, values) {

    //TODO: Do we need to remove special characters from states or has that already been done?

    // color and text for status
    var statusNames = ['Good', 'At Risk', 'Critical', 'Not Started', 'Completed'];
    var statusIndex = 0;
    var timeboxStartDate = convertDateStringToDateObject(startDate.slice(0, 10));
    var timeboxEndDate = convertDateStringToDateObject(endDate.slice(0, 10));
    var currentDate = new Date();

    if (timeboxStartDate > currentDate) {
        return statusNames[3];
    } else if (currentDate > timeboxEndDate) {
        return statusNames[4];
    }

    // get percentWorkComplete
    var acceptedWork = 0;
    var totalWork = 0;
    for (var i = 0; i < states.length; i++) {
        if (states[i] === 'Accepted') {
            acceptedWork += Math.round(values[i]);
        }
        if ((i >= 1) && (states[i-1] === 'Accepted')) {
            acceptedWork += Math.round(values[i]);
        }
        totalWork += Math.round(values[i]);
    }
    var percentWorkComplete = Math.round((acceptedWork / totalWork) * 100);

    // get percentTimeboxComplete
    var workDaysInTimebox = calcWorkDays(timeboxStartDate, timeboxEndDate);
    //don't include today in workDaysCompleted calculation
    var workDaysCompleted = calcWorkDays(timeboxStartDate, currentDate) - 1;
    var workDaysRemaining = calcWorkDays(currentDate, timeboxEndDate);
    var percentTimeboxComplete = Math.round((workDaysCompleted / workDaysInTimebox) * 100);

    // work points to release days ratio
    var healthRatio =
            Math.round((percentWorkComplete / percentTimeboxComplete) * 100);
    if (healthRatio >= 70 && healthRatio < 90) {
        statusIndex = 1;
    } else if (healthRatio < 70) {
        statusIndex = 2;
    }
    return [statusNames[statusIndex],
        workDaysRemaining,
        workDaysInTimebox,
        percentWorkComplete];
}

function removeEmptyValues(arr) {
    var nonEmpty = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            nonEmpty.push(arr[i]);
        }
    }
    return nonEmpty;
}
/*
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 Dashboard.js
 */
dojo.addOnLoad(initPage);

var BATCH_TOOLKIT, DROPDOWN, DASHBOARD;
var legendPane = null;

function checkForScopeUp(scopeUp) {
    var warningDiv = document.getElementById('warning');
    if (scopeUp === '__PROJECT_' + 'SCOPING_UP__' || typeof scopeUp === 'undefined') {
        warningDiv.style.visibility = 'hidden';
        return;
    } else {
        if (scopeUp === 'true') {
            warningDiv.style.visibility = 'visible';
            warningDiv.innerHTML = 'You have scope up ' +
                    '(show items from parent projects) turned on, ' +
                    'which produces unexpected results.  Click the ' +
                    'help icon for more information.';
        } else {
            warningDiv.style.visibility = 'hidden';
        }
    }
}

//TODO: Figure out a clever way to make a function that can return the value of a hangman
//  variable or a default if it has not been interpolated
function getAvailableWidth() {
    var browserWidth = document.body.clientWidth || window.innerWidth;
    if ('__width__' !== '__w' + 'idth__') {
        return '__width__';
    } else {
        return browserWidth;
    }
}

function getWidgetOid() {
    if ('__panelOid__' !== '__panel' + 'Oid__') {
        return '__panelOid__';
    } else {
        return 'mashup';
    }
}

function drawLegend(allowedValues, config) {
    var titleString = '';

    if (config.showScheduledWorkChart === true) {
        titleString +=  '<div style="width: ' + config.chartWidth +
                'px; float: left; text-align: center;">Scheduled Work</div>';
    }
    if (config.showTestCaseChart === true) {
        titleString +=  '<div style="width: ' + config.chartWidth +
                'px; float: left; text-align: center;">Test Cases</div>';
    }
    if (config.showDefectChart === true) {
        titleString +=  '<div style="width: ' + config.chartWidth +
                'px; float: left; text-align: center;">Defects</div>';
    }
    if (config.showBurndownChart === true) {
        titleString +=  '<div style="width: ' + config.chartWidth +
                'px; float: left; text-align: center;">Burndown</div>';
    }

    if (legendPane === null) {
        legendPane = new dijit.TitlePane( {title:titleString, open:false}, dojo.byId("legendDiv"));
    }

    var legendConfig = {
        width: config.chartWidth,
        height: 100,
        legendClass: 'dashboard-legend',
        id: 'myLegend',
        boxClass: 'dashboard-boxstyle',
        labelClass: 'dashboard-labelstyle'
    };

    if (config.showScheduledWorkChart === true) {
        var labels1 = allowedValues.scheduleStates;
        var colors1 = RALLY.Mashup.Pie.getColors(allowedValues.scheduleStates);
        var legend1 = new RALLY.Mashup.Legend(legendConfig, colors1, labels1);
        legend1.replace("placeholder1");
    } else {
        document.getElementById('placeholder1').style.display = 'none';
    }

    if (config.showTestCaseChart === true) {
        var labels2 = allowedValues.testVerdicts;
        labels2.push("No Result");
        var colors2 = RALLY.Mashup.Pie.getColors(allowedValues.testVerdicts);
        var legend2 = new RALLY.Mashup.Legend(legendConfig, colors2, labels2);
        legend2.replace("placeholder2");
    } else {
        document.getElementById('placeholder2').style.display = 'none';
    }

    if (config.showDefectChart === true) {
        var labels3 = allowedValues.defectStates;
        var colors3 = RALLY.Mashup.Pie.getColors(allowedValues.defectStates);
        var legend3 = new RALLY.Mashup.Legend(legendConfig, colors3, labels3);
        legend3.replace("placeholder3");
    } else {
        document.getElementById('placeholder3').style.display = 'none';
    }
}

function getAllowedValuesFromTypeDefs(result) {

    var typeDefsKeys = [];
    var allowedValuesHash = {};
    var allowedValuesStrings = [];

    // Result will come back as a hash: {"errors": [], "warnings": [], "keyNameInQueryConfig":typeDefsObject}
    // We need to loop through the hash fields to grab just the typeDefs key since we don't know which key we were passed, per se
    for (var property in result) {
        if (result.hasOwnProperty(property)) {
            if ((property !== "errors") && (property !== "warnings")) {
                allowedValuesHash[property] = [];
                typeDefsKeys.push(property);
            }
        }
    }

    for (var i=0; i<typeDefsKeys.length; i++) {
        var typeDefsKey = typeDefsKeys[i];
        var typeDefs = result[typeDefsKey];
        var artifactType = typeDefs[0].Name;
        var objectFieldName = "";

        objectFieldName = fieldNameByArtifact[artifactType];

        var attributes = typeDefs[0].Attributes;
        for (var j=0; j<attributes.length; j++) {
            var attrName = attributes[j].Name;
            if (attrName === objectFieldName) {
                var allowedValues = attributes[j].AllowedValues;
                allowedValuesStrings = [];
                for (var k=0; k<allowedValues.length; k++) {
                    allowedValuesStrings.push(allowedValues[k].StringValue);
                }
                allowedValuesHash[typeDefsKey] = allowedValuesStrings;
            }
        }
    }
    return allowedValuesHash;
}

function showDashboard(results) {
    var maxWidthForTwoColumns = 700;
    var allowedValues = {};

    var allowedValuesFromTypeDefs = getAllowedValuesFromTypeDefs(results);

    // allowedValues.scheduleStates = removeEmptyValues(allowedValuesFromTypeDefs.scheduleState);
    // allowedValues.testVerdicts = removeEmptyValues(results.testResult);
    // allowedValues.defectStates = removeEmptyValues(results.defectState);

    allowedValues.scheduleStates = removeEmptyValues(allowedValuesFromTypeDefs.scheduleState);
    allowedValues.testVerdicts = removeEmptyValues(allowedValuesFromTypeDefs.testResult);
    allowedValues.defectStates = removeEmptyValues(allowedValuesFromTypeDefs.defectState);

    function dashboardCallback(states, values) {
    }

    function calcChartWidth(chartWidth, pixelBuffer, numCols){
        return (chartWidth - pixelBuffer) / numCols;
    }

    var config = {
        showBurndownChart: true,
        showTestCaseChart: true,
        showDefectChart: true,
        showScheduledWorkChart: true,
        showTitle: true,
        browserWidth: CHART_WIDTH*0.90,
        chartWidth: calcChartWidth(CHART_WIDTH*0.9, 200, 4),
        LeftAxisVisible: true,
        RightAxisVisible: true,
        BottomAxisVisible: true,
        mashupType: MASHUP_TYPE,
        timeboxType: TIMEBOX_TYPE,
        specialVersion: SPECIAL_VERSION,
        burndownUnits: BURNDOWN_UNITS,
        allowedValues: allowedValues,
        projectOidsInScope: PROJECT_OIDS_IN_SCOPE,
        workspaceOid: WORKSPACE_OID
    };

    if (WIDGET_MODE) {
        config.showTitle = false;
        config.LeftAxisVisible = false;
        config.RightAxisVisible = false;
        config.BottomAxisVisible = false;
        if (CHART_WIDTH < maxWidthForTwoColumns) {
            config.showDefectChart = false;
            config.showTestCaseChart = false;
            config.showTitle = false;
            config.chartWidth = calcChartWidth(CHART_WIDTH*0.9, 150, 2);
        }
    }

    if (MASHUP_TYPE === RALLY.Mashup.PROGRAM) {
        config.programName = DROPDOWN.getSelectedName();
        config.programStart = DROPDOWN.getSelectedStart();
        config.programEnd = DROPDOWN.getSelectedEnd();
        config.releaseOids = DROPDOWN.getSelectedOids();
        config.dropdown = DROPDOWN;
    } else if (MASHUP_TYPE === RALLY.Mashup.ITERATION || MASHUP_TYPE === RALLY.Mashup.RELEASE) {
        config.projectOid = PROJECT_OID;
        config.timeboxName = DROPDOWN.getSelectedName();
        config.timeboxStart = DROPDOWN.getSelectedStart();
        config.timeboxEnd = DROPDOWN.getSelectedEnd();
        config.selectedOids = DROPDOWN.getSelectedOids();
        config.levels = 1;
    } else if (MASHUP_TYPE === RALLY.Mashup.CURRENT) {
        config.projectOid = PROJECT_OID;
        config.LeftAxisVisible = false;
        config.RightAxisVisible = false;
        config.BottomAxisVisible = false;
        if (CHART_WIDTH < maxWidthForTwoColumns){
            config.chartWidth = calcChartWidth(CHART_WIDTH*0.9, 150, 2);
        } else {
            config.chartWidth = calcChartWidth(CHART_WIDTH*0.7, 200, 4);
        }
    }

    if (typeof DASHBOARD === "undefined") {
        if (MASHUP_TYPE === RALLY.Mashup.PROGRAM) {
            // RALLY.Mashup.Utilities.showMashupHelp('Program+Dashboard+App', '__SERVER_URL__');
            //RALLY.Mashup.Utilities.showMashupHelp('Program+Dashboard+App', 'https://test7cluster.rallydev.com/slm');
            DASHBOARD = new RALLY.Mashup.ProgramHealth(BATCH_TOOLKIT, dashboardCallback);
        } else if (MASHUP_TYPE === RALLY.Mashup.RELEASE || MASHUP_TYPE === RALLY.Mashup.ITERATION) {
            // RALLY.Mashup.Utilities.showMashupHelp('Release+and+Iteration+Dashboard+App', '__SERVER_URL__');
            //RALLY.Mashup.Utilities.showMashupHelp('Release+and+Iteration+Dashboard+App', 'https://test7cluster.rallydev.com/slm');
            DASHBOARD = new RALLY.Mashup.TimeboxHealth(BATCH_TOOLKIT, dashboardCallback);
        } else if (MASHUP_TYPE === RALLY.Mashup.CURRENT) {
            DASHBOARD = new RALLY.Mashup.CurrentHealth(BATCH_TOOLKIT, dashboardCallback);
        }
    }

    document.getElementById('legendDiv').style.display = 'block';
    drawLegend(allowedValues, config);
    document.getElementById('legendDiv').style.width = config.browserWidth - 30 + 'px';

    DASHBOARD.display(config);
}

function runAllowedValuesQuery() {
    var queryArray = [];

    // queryArray[0] = {
    //     key: 'scheduleState',
    //     type: 'Hierarchical Requirement',
    //     attribute: 'Schedule State',
    //     workspace: '/workspace/' + WORKSPACE_OID
    // };
    // queryArray[1] = {
    //     key: 'testResult',
    //     type: 'Test Case',
    //     attribute: 'Last Verdict',
    //     workspace: '/workspace/' + WORKSPACE_OID
    // };
    // queryArray[2] = {
    //     key: 'defectState',
    //     type: 'Defect',
    //     attribute: 'State',
    //     workspace: '/workspace/' + WORKSPACE_OID
    // };

    // Workaround below to query TypeDefinitions directly since the adhoc placeholder query for allowed attributes
    // has a bug, DE24703

    // BE CAREFUL!! Note that when Querying TypeDefinitions, Artifact Names always have a space, as do the
    // Names of Fields, i.e. "Schedule State"

    queryArray[0] = {
      type : 'TypeDefinition',
      key : 'scheduleState',
      fetch: 'Name,Attributes',
      query: '(Name = "Hierarchical Requirement")',
      workspace: '/workspace/' + WORKSPACE_OID
    };
    queryArray[1] = {
        type: 'TypeDefinition',
        key: 'testResult',
        fetch: 'Name,Attributes',
        query: '(Name = "Test Case")',
        workspace: '/workspace/' + WORKSPACE_OID
    };
    queryArray[2] = {
        type: 'TypeDefinition',
        key: 'defectState',
        fetch: 'Name,Attributes',
        query: '(Name = "Defect")',
        workspace: '/workspace/' + WORKSPACE_OID
    };
    try {
        BATCH_TOOLKIT.findAll(queryArray, showDashboard);
    } catch(err) {
        console.error(err);
    }
}

function getMode(mode) {
    if (mode !== '__MO' + 'DE__') {
        return mode;
    }

    return 'webtab';
}

function initPage() {
    var widgetId = getWidgetOid();
    var config = {};

    document.getElementById('legendDiv').style.display = 'none';

    WIDGET_MODE = getMode('__MODE__') === 'widget' || getMode('__MODE__') === 'panel';
    CHART_WIDTH = getAvailableWidth();

    if (typeof(PROJECT_OID) !== "undefined") {
        config.project = "/project/"+ PROJECT_OID;
    }
    if (typeof(WORKSPACE_OID) !== "undefined") {
        config.workspace = "/workspace/"+ WORKSPACE_OID;
    }
    config.projectScopeDown = false;
    config.projectScopeUp = false;

    if (WIDGET_MODE) {
        document.getElementById('warning').style.display = 'none';
        document.getElementById('helpAndActions').style.display = 'none';
        document.getElementById('title').style.display = 'none';
    } else {
        checkForScopeUp('__PROJECT_SCOPING_UP__');
        RALLY.Mashup.Utilities.showPrintButton();
    }

    BATCH_TOOLKIT = new RALLY.Mashup.BatchToolkit(WORKSPACE_OID, PROJECT_OID,
            SCOPE_UP, SCOPE_DOWN);

    // BATCH_TOOLKIT.setServer('test7cluster.rallydev.com');

    if (MASHUP_TYPE === RALLY.Mashup.CURRENT) {
        runAllowedValuesQuery();

    } else {
        DROPDOWN = new RALLY.Mashup.Dropdown(BATCH_TOOLKIT, MASHUP_TYPE,
                'timeboxList', 'timeboxLabel', 'mu_dashboard_' + MASHUP_TYPE.toLowerCase() +
                        '_' + widgetId,config);
        DROPDOWN.invoke(runAllowedValuesQuery);
    }

}
//---compress---/
/*!
 Copyright (c) 2002-2010  Rally Software Development Corp. All rights reserved.
 timebox-health.js
 */
var RALLY = RALLY || {};
RALLY.Mashup = RALLY.Mashup || {};

RALLY.Mashup.TimeboxHealth = function(batchToolkit, callback) {
    var INDENT_WIDTH = 40;
    var ALLOWED_VALUES = {};

    // --- Private variables --------------------------------------

    var that = this;
    var config = {};

    function formatHealth(status) {
        var content = [];
        var images = {
            'Good': 'check-icon.gif',
            'At Risk': 'caution-icon.gif',
            'Critical': 'error-icon.gif'
        };

        if (status[0] === 'Good' || status[0] === 'At Risk' || status[0] === 'Critical') {
            content[0] = '&nbsp;' +
                    '<img border="0" align="Absmiddle" src="/slm/mashup/1.15/images/' + images[status[0]] +
                    '" alt="' + status[0] + '"/>' +
                    '&nbsp;' + config.timeboxType + ' Health is <b>' + status[0] + '</b>.';

            content[1] = '&nbsp;' + 'With ' +
                    status[1] + ' days remaining in a ' + status[2] + '-day ' +
                    config.timeboxType.toLowerCase() + ', ' + status[3] +
                    '% has been accepted.';
        } else {
            content[0] = ' - ' + config.timeboxType + ' is ' + status;
            content[1] = '';
        }
        return content;
    }

    function createTimeboxHeader(parentElement, name, level, rowNum, cnt) {
        var projectNameDiv, healthDiv, text;

        projectNameDiv = document.createElement("DIV");
        projectNameDiv.innerHTML = '';
        projectNameDiv.style.marginLeft = level * INDENT_WIDTH + 'px';
        projectNameDiv.innerHTML += '&nbsp;' + name;
        projectNameDiv.id = 'row' + rowNum + '_header';
        projectNameDiv.className = 'dashboard-heading';
        parentElement.appendChild(projectNameDiv);

        healthDiv = document.createElement("DIV");
        healthDiv.id = 'row' + rowNum + '_health';
        healthDiv.className = 'dashboard-health';
        healthDiv.style.marginLeft = level * INDENT_WIDTH + 'px';
        parentElement.appendChild(healthDiv);
    }

    function createTimeboxFooter(parentElement, rowNum, level) {
        var projectNameDiv;

        projectNameDiv = document.createElement("DIV");
        projectNameDiv.innerHTML = '';
        projectNameDiv.style.marginLeft = level * INDENT_WIDTH + 'px';
        projectNameDiv.id = 'row' + rowNum + '_footer';
        projectNameDiv.className = 'dashboard-footer';
        parentElement.appendChild(projectNameDiv);
    }

    function createChartRow(parentElement, name, level, rowNum) {
        var div, div2, text, i;
        var width = config.chartWidth;
        var cnt = 0;
        var container = document.createElement("DIV");
        container.id = 'pie_container_' + rowNum;
        container.className += 'dashboard-rowContainer';

        // determine how many divs to draw
        for (var n in config) {
            if (n.match(/show\w+Chart/) !== null && config[n] === true) {
                cnt += 1;
            }
        }

        createTimeboxHeader(container, name, level, rowNum, cnt);

        for (i = 0; i < cnt; i++) {
            div = document.createElement("DIV");

            div.className = "dashboard-chart";
            div.id = 'row' + rowNum + '_div' + i;
            div.style.width = width + 'px';
            div.style.height = width * 0.6 + 'px';
            if (i === 0) {
                //indent row based on level
                div.style.marginLeft = level * INDENT_WIDTH + 'px';
            }

            //Create a smaller div inside the main div, since Emprise does not
            //give us the ability to specify a margin around the chart
            div2 = document.createElement("DIV");
            div2.id = 'row' + rowNum + '_div' + i + '_inner';
            div2.style.width = width * 0.9 + 'px';
            div2.style.height = width * 0.55 + 'px';
            //div2.style.paddingLeft = '10px';
            div.appendChild(div2);

            container.appendChild(div);
        }

        createTimeboxFooter(container, rowNum, level);
        parentElement.appendChild(container);
    }

    function afterDisplayCallback(chartDiv) {
        RALLY.Mashup.Utilities.hideWait('spinner', chartDiv);
    }

    function getChartDivCount(){
        var cnt = 0;

        for (var n in config) {
            if (n.match(/show\w+Chart/) !== null && config[n] === true) {
                cnt += 1;
            }
        }
        return cnt;
    }


    function buildPie(artifactType, artifactAttribute, chartDiv, rowNum, projectInfo, cssClass, artifactData) {
        var pieChart;

        function checkForData(values){
            var i;
            for (i = 0; i < values.length; i++){
                if (values[i] > 0) {
                    return true;
                }
            }
            return false;
        }

        function pieCallback(timeboxStart, timeboxEnd, states, values) {
            var health, healthStuff, dataExists;

            if (artifactType === 'ScheduledWork') {
                dataExists = checkForData(values);

                if (dataExists){
                    health = calculateHealth(timeboxStart, timeboxEnd, states, values);

                    if (health !== null && !isNaN(health[3])) {
                        healthStuff = formatHealth(health);
                        document.getElementById('row' + rowNum + '_header').innerHTML += healthStuff[0];
                        document.getElementById('row' + rowNum + '_health').innerHTML = healthStuff[1];
                    } else if (health === 'Completed' || health === 'Not Started'){
                        document.getElementById('row' + rowNum + '_header').innerHTML += ' - ' + config.mashupType + ' is ' + health;
                    }
                } else {
                    divNum = getChartDivCount();

                    // hide pies and burndown since no data
                    for (i=0; i<divNum; i++){
                        document.getElementById('row' + rowNum + '_div' + i).className = 'dashboard-hide-chart';
                    }

                    document.getElementById('row' + rowNum + '_health').innerHTML += '&nbsp;No Data';
                }
            }
        }

        var pieWidth = config.chartWidth * 0.90 - (projectInfo.Level);
        var pieHeight = pieWidth * 0.50;

        if (config.browserWidth < 600) {
            pieHeight = pieWidth * 0.80;
        }
        var tempChartDiv;
        var options = {
            allowedValues: config.allowedValues,
            timeboxName: config.timeboxName,
            timeboxStart: config.timeboxStart,
            timeboxEnd: config.timeboxEnd,
            timeboxType: config.timeboxType,
            artifactType: artifactType,
            artifactAttribute: artifactAttribute,
            chartDiv: chartDiv + '_inner',
            projectOid: projectInfo.ObjectID,
            workspaceOid: config.workspaceOid,
            pieWidth: pieWidth,
            pieHeight: pieHeight,
            artifactData: artifactData
        };

        tempChartDiv = document.getElementById(chartDiv);
        tempChartDiv.setAttribute("class", cssClass);
        tempChartDiv.setAttribute("className", cssClass);

        pieChart = new RALLY.Mashup.Pie(batchToolkit, options, pieCallback);
        pieChart.display();
    }

    function buildBurndown(chartDiv, projectOid) {
        var burndown;
        var options = {
            BurndownIdealVisible: true,
            LeftAxisLabelVisible: false,
            BottomAxisLabelVisible: false,
            RightAxisLabelVisible: false,
            ChartType: 'burndown',
            Units: config.burndownUnits,
            LeftAxisVisible: config.LeftAxisVisible,
            RightAxisVisible: config.RightAxisVisible,
            BottomAxisVisible: config.BottomAxisVisible
        };

        if (!config.specialVersion) {
            options.CompletedVisible = false;
        }

        burndown = new RALLY.Mashup.SuperCustomizableChart(batchToolkit, null,
                config.timeboxName, config.timeboxStart,
                config.timeboxEnd, config.timeboxType, options, chartDiv + '_inner', null,
                projectOid, afterDisplayCallback);

        burndown.display();
    }

    function drawBurndown(currentProject, rowNum, numPies) {
        if (config.showBurndownChart) {
            buildBurndown('row' + rowNum + '_div' + numPies, currentProject.ObjectID);
        }
    }

    function buildTimeboxQueryString(timeboxType, timeboxStart, timeboxEnd, timeboxName) {

        function getTimeboxStartFieldName(timeboxType) {
            return timeboxType === RALLY.Mashup.ITERATION ? "StartDate" : "ReleaseStartDate";
        }

        function getTimeboxEndFieldName(timeboxType) {
            if (timeboxType === RALLY.Mashup.ITERATION) {
                return "EndDate";
            } else {
                return "ReleaseDate";
            }
        }

        var startDateName = getTimeboxStartFieldName(timeboxType);
        var endDateName = getTimeboxEndFieldName(timeboxType);
        return '( ( ( ' + timeboxType + '.Name = "' +
                timeboxName +
                '" ) AND ( ' + timeboxType + '.' + startDateName + ' = "' +
                timeboxStart +
                '" )) AND ( ' + timeboxType + '.' + endDateName + ' = "' +
                timeboxEnd + '" ))';
    }

    function getAllowedValues(callback) {
        if (config.allowedValues) {
            allowedValues = config.allowedValues;
            callback();
        } else {
            // runAllowedValuesQuery(callback);
            console.log('Allowed Values are not known at this point... Problem.');
        }
    }

    function addScopeSettings(query) {
        // I'm kinda assuming this isn't the best way to do this, since SCOPE_UP and SCOPE_DOWN are global variables, so i kept the comment-out 'acceptable' way.
        if (typeof SCOPE_UP !== 'undefined') {
            query.projectScopeUp = SCOPE_UP;
        }
        if (typeof SCOPE_DOWN !== 'undefined') {
            query.projectScopeDown = SCOPE_DOWN;
        }
        // if (typeof config.scopeUp !== 'undefined') {
        //     query.projectScopeUp = config.scopeUp;
        // }
        // if (typeof config.scopeDown !== 'undefined') {
        //     query.projectScopeDown = config.scopeDown;
        // }
    }

    function sumDataObjectContents(data1, data2) {
        if (typeof data1 == 'undefined') {
            data1 = {};
        }
        if (typeof data2 == 'undefined') {
            data2 = {};
        }
        for (var x in data1) {
            if (data1.hasOwnProperty(x)) {
                if (data2[x]) {
                    data2[x] = parseInt(data2[x], 10) + parseInt(data1[x], 10);
                } else {
                    data2[x] = parseInt(data1[x], 10);
                }
            }
        }
        return data2;
    }

    function ensureAllowedValues(allowedArray, states, values) {
        var i,result = {states:[],values:[]};

        for (i = 0; i < allowedArray.length; i++) {
            // for test case results, check for state=null
            if (allowedArray[i] === 'No Result'){
                if (states.findIndex("null") === null) {
                    result.states.push('No Result');
                    result.values.push(0);
                } else {
                    result.states.push('No Result');
                    result.values.push(values[states.findIndex("null")]);
                }
            }

            if (states.findIndex(allowedArray[i]) === null) {
                result.states.push(allowedArray[i]);
                result.values.push(0);
            } else {
                result.states.push(allowedArray[i]);
                result.values.push(values[states.findIndex(allowedArray[i])]);
            }
        }
        return result;
    }

    function executeQuery(query, currentProjectOid, callback) {
        //add project here
        for (var i = 0; i < query.length; i++) {
            query[i].project = "/project/" + currentProjectOid;
            query[i].workspace = "/workspace/" + config.workspaceOid;
            addScopeSettings(query[i]);
        }
        batchToolkit.find(query, callback);
    }

    function getArtifactCounts(currentProjectOid, callback) {
        var countQuery = [];
        var storyCountKey,defectCountKey,defectSuiteKey,theFilter;

        theFilter = buildTimeboxQueryString(config.timeboxType, config.timeboxStart,
                config.timeboxEnd, config.timeboxName);

        storyCountKey = '#stories';
        defectCountKey = '#defects';
        defectSuiteKey = '#defectSuiteKey';

        countQuery[0] = {
            key: storyCountKey,
            type: "hierarchicalrequirement",
            fetch: false,
            query: theFilter
        };
        countQuery[1] = {
            key: "story_count",
            placeholder: "${" + storyCountKey + "/size}"
        };
        countQuery[2] = {
            key: defectCountKey,
            type: "defect",
            fetch: false,
            query: theFilter
        };
        countQuery[3] = {
            key: "defect_count",
            placeholder: "${" + defectCountKey + "/size}"
        };
        countQuery[4] = {
            key: defectSuiteKey,
            type: "defectsuite",
            fetch: false,
            query: theFilter
        };
        countQuery[5] = {
            key: "defect_suite_count",
            placeholder: "${" + defectSuiteKey + "/size}"
        };

        executeQuery(countQuery, currentProjectOid, callback);
    }

    function hideRow(rowNum) {
        // this code is from PieCallback
        var divNum = getChartDivCount();

        // hide pies and burndown since no data
        for (i=0; i<divNum; i++){
            document.getElementById('row' + rowNum + '_div' + i).className = 'dashboard-hide-chart';
        }

        document.getElementById('row' + rowNum + '_health').innerHTML += '&nbsp;No Data';
    }

    function drawPies(currentProject, rowNum) {
        var chartCnt = 0, cnt = 0, queryArr = [];
        var theFilter, maxCount;
        var storyCountKey, defectCountKey, defectSuiteKey;

        var storyCount, defectCount, defectSuiteCount;

        var scheduledWorkResults, defectResults, testCaseResults;

        storyCountKey = '#stories';
        defectCountKey = '#defects';
        defectSuiteKey = '#defectSuiteKey';

        function countCallback(results)
        {
            storyCount = results.story_count;
            defectCount = results.defect_count;
            defectSuiteCount = results.defect_suite_count;

            getAllowedValues(gatherArtifactCounts);
        }

        function gatherArtifactCounts() {
            var artifactCountIndex = 0, finishedCount = 0, done = false;
            var states = [], values = [];
            var tempSWPieObject = null, tempDPieObject = null, tempTCPieObject = null;

            maxCount = Math.max(storyCount, defectCount, defectSuiteCount);

            theFilter = buildTimeboxQueryString(config.timeboxType, config.timeboxStart, config.timeboxEnd, config.timeboxName);

            for (artifactCountIndex = 0; artifactCountIndex * 200 < maxCount; artifactCountIndex++) {
                if (storyCount > artifactCountIndex * 200) {
                    queryArr.push({
                        key: storyCountKey,
                        type: "hierarchicalrequirement",
                        fetch: false,
                        query: theFilter + "&start=" + (1 + ( artifactCountIndex * 200)),
                        pagesize: 200
                    }, { // from get scheduled work
                        key: "grouped_stories_by_schedulestate",
                        placeholder: "${" + storyCountKey + "/[group(schedulestate,size)]}"
                    }, { // from get defects
                        key: "grouped_stories_by_state",
                        placeholder: "${" + storyCountKey + "/defects/[group(state,size)]}"
                    }, { // from get test cases
                        key: "grouped_stories_by_lastverdict",
                        placeholder: "${" + storyCountKey + "/testcases/[group(lastverdict,size)]}"
                    });
                }
                if (defectCount > artifactCountIndex * 200) {
                    queryArr.push({
                        key: defectCountKey,
                        type: "defect",
                        fetch: false,
                        query: theFilter + "&start=" + (1 + ( artifactCountIndex * 200)),
                        pagesize: 200
                    }, { // from get scheduled work
                        key: "grouped_defects_by_schedulestate",
                        placeholder: "${" + defectCountKey + "/[group(schedulestate,size)]}"
                    }, { // from get defects
                        key: "grouped_defects_by_state",
                        placeholder: "${" + defectCountKey + "/[group(state,size)]}"
                    });
                }
                if (defectSuiteCount > artifactCountIndex * 200) {
                    queryArr.push({
                        key: defectSuiteKey,
                        type: "defectsuite",
                        fetch: false,
                        query: theFilter + "&start=" + (1 + ( artifactCountIndex * 200)),
                        pagesize: 200
                    }, { // from get scheduled work
                        key: "grouped_defect_suites_by_schedulestate",
                        placeholder: "${" + defectSuiteKey + "/[group(schedulestate,size)]}"
                    });
                }
                // loop this for each "page" of results
                executeQuery(queryArr, currentProject.ObjectID, formatDataCallback);
            }
            done = true;

            // If this is true, no queries will be run, but we want code to get to 'render' so the pies & burndown will be hidden - since there will be no data.
            if (maxCount === 0) {
                hideRow(rowNum);
            }

            function formatDataCallback(results) {
                // scheduled work pie object building:
                if (tempSWPieObject === null) {
                    tempSWPieObject = sumDataObjectContents(results.grouped_stories_by_schedulestate, sumDataObjectContents(results.grouped_defect_suites_by_schedulestate, results.grouped_defects_by_schedulestate));
                } else {
                    tempSWPieObject = sumDataObjectContents(sumDataObjectContents(results.grouped_stories_by_schedulestate,sumDataObjectContents(results.grouped_defect_suites_by_schedulestate, results.grouped_defects_by_schedulestate)), tempSWPieObject);
                }

                // defect pie object building:
                if (tempDPieObject === null) {
                    tempDPieObject = sumDataObjectContents(results.grouped_stories_by_state, results.grouped_defects_by_state);
                } else {
                    tempDPieObject = sumDataObjectContents(sumDataObjectContents(results.grouped_stories_by_state, results.grouped_defects_by_state), tempDPieObject);
                }

                // test case pie object building:
                if (tempTCPieObject === null) {
                    tempTCPieObject = results.grouped_stories_by_lastverdict;
                } else {
                    tempTCPieObject = sumDataObjectContents(results.grouped_stories_by_lastverdict, tempTCPieObject);
                }

                finishedCount++;

                // once it's done, load pies:
                if (done && artifactCountIndex == finishedCount) {
                    if (config.showScheduledWorkChart) {
                        buildPie('ScheduledWork', 'ScheduleState', 'row' + rowNum + '_div' + cnt, rowNum, currentProject, "dashboard-FirstChart", tempSWPieObject);
                        cnt++;
                    }
                    if (config.showTestCaseChart) {
                        buildPie('TestCase', 'LastVerdict', 'row' + rowNum + '_div' + cnt, rowNum, currentProject, "dashboard-SecondChart", tempTCPieObject);
                        cnt++;
                    }
                    if (config.showDefectChart) {
                        buildPie('Defect', 'State', 'row' + rowNum + '_div' + cnt, rowNum, currentProject, "dashboard-ThirdChart", tempDPieObject);
                        cnt++;
                    }
                }
            }
        }

        getArtifactCounts(currentProject.ObjectID, countCallback);

        if (config.showScheduledWorkChart) chartCnt++;
        if (config.showTestCaseChart) chartCnt++;
        if (config.showDefectChart) chartCnt++;
        return chartCnt;
    }

    function clearCharts() {
        var charts = document.getElementById('charts');
        while (charts.hasChildNodes()) {
            charts.removeChild(charts.firstChild);
        }
    }

    function buildPage(projectArray) {
        var chartsDiv, currentProject, i,numPies;
        clearCharts();

        if (config.showTitle) {
            document.getElementById('title').style.display = '';
            formatTitle();
        } else {
            document.getElementById('title').style.display = 'none';
        }

        chartsDiv = document.getElementById('charts');
        chartsDiv.style.width = config.browserWidth - 50 + 'px';

        for (i = 0; i < projectArray.length; i++) {
            createChartRow(chartsDiv, projectArray[i].Name, projectArray[i].Level, i);
        }
        for (i = 0; i < projectArray.length; i++) {
            numPies = drawPies(projectArray[i], i);
        }
        for (i = 0; i < projectArray.length; i++) {
            drawBurndown(projectArray[i], i, numPies);
        }
    }

    function callProjectTree(results) {
        var currentProject = config.projectOid;
        var projectArr = parseProjectTree(currentProject, results);
        buildPage(projectArr);
    }

    function parseProjectTree(currentProject, results) {
        var projectArray = [];
        var maxLevel;
        var count = 0;
        var level = config.levels;

        if (config.levels === 0) {
            maxLevel = 0;
        } else if (!config.specialVersion) {
            maxLevel = 1;
        }

        // start gathering projects starting with the currentProject then iteration through children
        gatherProjects(results.projects, currentProject);

        // Used to sort children into alphabetical order
        function sortChild(a, b) {
            return a._refObjectName >= b._refObjectName;
        }

        // Strip the oid from the reference
        function getOid(ref) {
            return ref.substring(ref.lastIndexOf('/') + 1, ref.lastIndexOf('.'));
        }

        function findProject(projects, oid) {
            for (var i = 0; i < projects.length; i++) {
                if (projects[i].ObjectID == oid) {
                    return projects[i];
                }
            }
            //throw "Error in FindProject";
            return null;
        }

        // Takes the array of projects and puts them into a hierarchy
        function gatherProjects(projects, currentProjectOid, level) {
            var project = findProject(projects, currentProjectOid);
            if (project === null || (typeof maxLevel !== 'undefined' && level > maxLevel)) {
                return;
            }

            if (typeof level === 'undefined') {
                level = 0;
            }

            if (project.State === 'Open') {
                projectArray[count] = {};
                projectArray[count].Name = project._refObjectName;
                projectArray[count].ObjectID = project.ObjectID;
                projectArray[count++].Level = level;
            }

            if (typeof project.Children !== 'undefined' && project.Children.length > 0) {
                //project.Children.sort(sortChild);
                for (var j = 0; j < project.Children.length; j++) {
                    gatherProjects(projects, getOid(project.Children[j]._ref), level + 1);
                }
            }
        }

        return projectArray;
    }

    function buildProjectQueryString(arrayOfOids, attributeName) {
        var query = "";
        var first = true;

        for (var i = 0; i < arrayOfOids.length; i++) {
            if (typeof arrayOfOids[i] !== 'undefined') {
                if (first) {
                    query = buildProjectSingleQuery(arrayOfOids[i]);
                    first = false;
                } else {
                    query = "(" + query + " OR " +
                            buildProjectSingleQuery(arrayOfOids[i]) + ")";
                }
            }
        }

        function buildProjectSingleQuery(value) {
            return "(" + attributeName + " = " + value + ")";
        }

        return query;
    }

    function projectQuery() {
        var projectsInScope = config.projectOidsInScope.split(',');
        var orQuery = buildProjectQueryString(projectsInScope, "ObjectID");
        var queryObject = {
            key: 'projects',
            type: 'project',
            query: orQuery,
            fetch: 'ObjectID,Name,State,Children',
            order: 'Name'
        };

        try {
            batchToolkit.findAll(queryObject, callProjectTree);
        } catch(err) {
            console.error(err);
        }

    }

    function formatTitle() {
        var div = document.getElementById('title');
        var units;
        if (config.burndownUnits === 'story') {
            units = 'plan estimates';
        } else {
            units = 'to do';
        }
        if (config.specialVersion) {
            div.innerHTML = config.mashupType + ' Dashboard (' + units + ')';
        } else {
            div.innerHTML = config.mashupType + ' Dashboard';
        }
    }

    function applyConfig(overrides) {
        config = {
            workspaceOid: overrides.workspaceOid,
            projectOid: overrides.projectOid,
            timeboxType: config.timeboxType,
            levels: 1,
            showBurndownChart: true,
            showTestCaseChart: true,
            showDefectChart: true,
            showScheduledWorkChart: true,
            showTitle: true,
            chartWidth: (config.browserWidth - 200) / 4
        };

        for (var property in overrides) {
            if (overrides.hasOwnProperty(property)) {
                config[property] = overrides[property];
            }
        }
    }

    // --- Public methods -----------------------------------------

    this.display = function(config) {
        applyConfig(config);
        projectQuery();
    };
    this.applyConfig = function(config){
        applyConfig(config);
    };
    this.parseProjectTree = function(currentProject, results) {
        return parseProjectTree(currentProject, results);
    };

    return that;
};

/*
 Copyright (c) 2002-2009  Rally Software Development Corp. All rights reserved.
 dropdown.js
 */

var RALLY = RALLY || {};
RALLY.Mashup = RALLY.Mashup || {};

//config holds all hangman varibles
RALLY.Mashup.Dropdown = function(toolkit, type, selElem, labelElem, cookiename, config) {

    // --- Private variables -----------------------------------------
    var that = this;
    var batchAPI = toolkit;
    var dropdownType = type;
    var selectElement = document.getElementById(selElem);
    var labelElement = document.getElementById(labelElem);
    var cookieName = cookiename;
    var callback;
    var timeboxList;
    var timeboxInfo = {};

    // Fix release picker size problem:
    config.projectScopeDown = false;

    // --- Private methods -----------------------------------------

    // Needed since start and end date field names are different
    // for iterations and releases
    function getTimeboxStartFieldName() {
        if (dropdownType === RALLY.Mashup.ITERATION) {
            return "StartDate";
        } else {
            return "ReleaseStartDate";
        }
    }

    // Needed since start and end date field names are different
    // for iterations and releases
    function getTimeboxEndFieldName() {
        if (dropdownType === RALLY.Mashup.ITERATION) {
            return "EndDate";
        } else {
            return "ReleaseDate";
        }
    }

    // Removes duplicates (timeboxes with same name/start/end) and
    // attaches a list of oids for each entry
    function buildTimeboxList(timeboxes) {
        var found, oidsInScope;
        var list = [];
        var startField = getTimeboxStartFieldName();
        var endField = getTimeboxEndFieldName();

        for (var i = 0; i < timeboxes.length; i++) {
            found = false;

            for (var j = 0; j < list.length; j++) {
                if (timeboxes[i].Name === list[j].Name &&
                        timeboxes[i][startField] === list[j][startField] &&
                        timeboxes[i][endField] === list[j][endField]) {
                    list[j].oidsInScope.push(timeboxes[i].ObjectID);
                    found = true;
                    break;
                }
            }
            if (!found) {
                timeboxes[i].oidsInScope = [];
                timeboxes[i].oidsInScope.push(timeboxes[i].ObjectID);
                list.push(timeboxes[i]);
            }
        }
        return list;
    }

    // Used for iteration/release to see if it occurs more than once
    function countOccurrences() {
        var occurrences = [];
        for (var i = 0; i < timeboxList.length; i++) {
            if (!occurrences[timeboxList[i].Name]) {
                occurrences[timeboxList[i].Name] = 1;
            } else {
                occurrences[timeboxList[i].Name] += 1;
            }
        }
        return occurrences;
    }

    function formatWithDates(listElement) {
        var startDateName = getTimeboxStartFieldName();
        var endDateName = getTimeboxEndFieldName();
        return listElement.Name +
                " (" + RALLY.Mashup.Utilities.formatDate(listElement[startDateName]) + " - " +
                RALLY.Mashup.Utilities.formatDate(listElement[endDateName]) + ")";
    }

    function formatValue(listElement, objectIds) {
        var startDateName = getTimeboxStartFieldName();
        var endDateName = getTimeboxEndFieldName();
        return listElement.Name + "~" +
                listElement[startDateName].slice(0, 10) + "~" +
                listElement[endDateName].slice(0, 10) + "~" +
                objectIds;
    }

    function makeCookie(valString) {
        var stuff = valString.split(/\s?~\s?/);
        return stuff[0] + '~' + stuff[1] + '~' + stuff[2];
    }

    function updateCookie() {
        var cookieVal = makeCookie(selectElement.options[selectElement.selectedIndex].value);
        RALLY.Mashup.Utilities.updateMashupCookie(cookieName, cookieVal, 30);
    }

    function onChange(e) {
        updateCookie();
        callback();
    }

    function addEventListener() {
        if (document.addEventListener) { // For most browsers
            selectElement.addEventListener('change', onChange, false);
        } else if (document.attachEvent) { // For IE
            selectElement.attachEvent('onchange', onChange);
        }
    }

    // For iterations and releases, selects the 'current' one
    function displayCurrentTimebox(results) {
        var hasCookie = RALLY.Mashup.Utilities.cookieExists(cookieName);
        var currentTimeboxOid, cookieVal, i, regex;

        if (hasCookie) {
            cookieVal = RALLY.Mashup.Utilities.readMashupCookie(cookieName);
            for (i = 0; i < selectElement.length; i++) {
                if (cookieVal === makeCookie(selectElement.options[i].value)) {
                    selectElement.selectedIndex = i;
                    break;
                }
            }

        } else if (results.currentTimebox.length === 0) {
            selectElement.selectedIndex = 0;

        } else {
            currentTimeboxOid = results.currentTimebox[0].ObjectID;
            regex = new RegExp(currentTimeboxOid);
            for (i = 0; i < selectElement.length; i++) {
                if (selectElement.options[i].value.match(regex)) {
                    selectElement.selectedIndex = i;
                }
            }
        }

        updateCookie();
        callback();
    }

    function findCurrentTimebox() {
        var today = new Date();
        var todayStr = today.getFullYear() + "-" +
                (today.getMonth() + 1) + "-" +
                today.getDate();
        var startDateName = getTimeboxStartFieldName();
        var endDateName = getTimeboxEndFieldName();
        var queryObject = {
            key: 'currentTimebox',
            type: dropdownType,
            query: '(' + endDateName + ' >= ' + todayStr + ')',
            fetch: 'Name,' + startDateName + ',' + endDateName + ',ObjectID',
            order: endDateName + ' asc'
        };
        configureQuery(queryObject);
        batchAPI.findAll(queryObject, displayCurrentTimebox);
    }

    function buildTimeboxSelectList() {
        var occurrences = countOccurrences();
        for (var i = 0; i < timeboxList.length; i++) {
            if (occurrences[timeboxList[i].Name] > 1) {
                selectElement.options[i] =
                        new Option(formatWithDates(timeboxList[i]),
                                formatValue(timeboxList[i], timeboxList[i].oidsInScope));
            } else {
                selectElement.options[i] =
                        new Option(timeboxList[i].Name,
                                formatValue(timeboxList[i], timeboxList[i].oidsInScope));
            }
        }
        findCurrentTimebox();
    }

    function buildProgramSelectList() {
        var utilities = RALLY.Mashup.Utilities;
        var n = 0;
        var releaseOids;

        for (var i = 0; i < timeboxList.length; i++) {
            var listElement = timeboxList[i];

            if (listElement.Releases.length > 0) {
                releaseOids = [];

                listElement.ReleaseStartDate = listElement.Releases[0].ReleaseStartDate;
                listElement.ReleaseDate = listElement.Releases[0].ReleaseDate;

                for (var cnt = 0; cnt < listElement.Releases.length; cnt++) {
                    var currentStartDate = listElement.Releases[cnt].ReleaseStartDate;
                    var currentEndDate = listElement.Releases[cnt].ReleaseDate;

                    // try to find min start and max end date
                    if (utilities.convertIsoToJSDate(currentStartDate) < utilities.convertIsoToJSDate(listElement.ReleaseStartDate)) {
                        listElement.ReleaseStartDate = currentStartDate;
                    }
                    if (utilities.convertIsoToJSDate(currentEndDate) > utilities.convertIsoToJSDate(listElement.ReleaseDate)) {
                        listElement.ReleaseDate = currentEndDate;
                    }
                    //TODO: Can we get rid of this? Chat with PPM
                    releaseOids.push(listElement.Releases[cnt].ObjectID);
                }
                selectElement.options[n] = new Option(listElement.Name, formatValue(listElement, releaseOids));
                n = n + 1;
            }
        }

        // fake results of 'current' query, since there is no "current" program
        results = {
            'currentTimebox' : [timeboxList[0]]
        };
        displayCurrentTimebox(results);
    }

    function buildDropdownSelection(results) {
        timeboxList = buildTimeboxList(results.timeboxes);

        if (timeboxList.length === 0) {
            selectElement.style.visibility = "hidden";
            labelElement.innerHTML = "No " + dropdownType + " found for " +
                    "current project or children project(s).<br> ";
            callback();
        } else {
            selectElement.style.visibility = "visible";
            labelElement.innerHTML = dropdownType;
        }

        if (dropdownType === RALLY.Mashup.PROGRAM) {
            buildProgramSelectList();
        } else {
            buildTimeboxSelectList();
        }
    }

    // Helper for which fields we want to fetch
    function getQueryFetchValue(startDateName, endDateName) {
        if (dropdownType === RALLY.Mashup.PROGRAM) {
            return "Name,Releases,ObjectID," + startDateName + "," + endDateName + "," + "Project";
        } else {
            return "Name,ObjectID," + startDateName + "," + endDateName + "";
        }
    }

    // Helper for how we want to sort
    function getQueryOrderValue(endDateName) {
        if (dropdownType === RALLY.Mashup.PROGRAM) {
            return 'Name';
        } else {
            return endDateName + ' desc';
        }
    }

    function runDropdownQuery() {
        var startDateName = getTimeboxStartFieldName();
        var endDateName = getTimeboxEndFieldName();
        var queryFetch = getQueryFetchValue(startDateName, endDateName);
        var queryOrder = getQueryOrderValue(endDateName);
        var queryObject = [];

        queryObject[0] = {
            key: 'timeboxes',
            type: dropdownType,
            fetch: queryFetch,
            order: queryOrder
        };
        configureQuery(queryObject[0]);

        if (type === RALLY.Mashup.PROGRAM) {
            queryObject[1] = {
                key: 'releases',
                placeholder: "${timeboxes.releases?fetch=ObjectID," +
                        startDateName + "," + endDateName + "&project=null}"
            };
        }


        batchAPI.findAll(queryObject, buildDropdownSelection);
    }

    function configureQuery(query) {
        if (typeof(config) !== "undefined") {
            if (typeof(config.workspace) !== "undefined") {
                query.workspace = config.workspace;
            }
            if (typeof(config.projectScopeUp) !== "undefined") {
                query.projectScopeUp = config.projectScopeUp;
            }
            if (typeof(config.projectScopeDown) !== "undefined") {
                query.projectScopeDown = config.projectScopeDown;
            }
            if (typeof(config.project) !== "undefined") {
                query.project = config.project;
            }
        }
    }

    function updateTimeboxInfo() {
        var selectedIndex = selectElement.selectedIndex;
        timeboxInfo = selectElement.options[selectedIndex].value.split(/\s?~\s?/);
    }

    function findOid(oid) {
        var oidList;
        for (var i = 0; i < timeboxList.length; i++) {
            oidList = timeboxList[i].oidsInScope;
            for (var j = 0; j < oidList.length; j++) {
                if (oidList[j] == oid) {
                    return i;
                }
            }
        }
        return -1;
    }

    // --- Public methods -----------------------------------------

    this.invoke = function(callback_function) {
        addEventListener();
        callback = callback_function;
        runDropdownQuery();
    };

    this.getDropdownType = function() {
        return dropdownType;
    };

    this.getSelectedName = function() {
        updateTimeboxInfo();
        // TODO better to have the name not the index
        return timeboxInfo[0];
    };

    // for releases/iterations, start date for release/iteration
    // for programs, start of the earliest release
    this.getSelectedStart = function() {
        updateTimeboxInfo();
        // TODO better to have the name not the index
        return timeboxInfo[1];
    };

    // for releases/iterations, end date for release/iteration
    // for programs, end of the latest release
    this.getSelectedEnd = function() {
        updateTimeboxInfo();
        // TODO better to have the name not the index
        return timeboxInfo[2];
    };

    // for releases/iterations, this is release/iterations OIDs selected and in scope
    // for programs, this is the release OIDs for the program selected
    this.getSelectedOids = function() {
        updateTimeboxInfo();
        // TODO better to have the name not the index
        return timeboxInfo[3];
    };

    // for iteration, returns the start date field name for iterations
    // for program and release, returns the start date field name for releases
    this.getStartFieldName = function() {
        return getTimeboxStartFieldName();
    };

    // for iteration, returns the end date field name for iterations
    // for program and release, returns the end date field name for releases
    this.getEndFieldName = function() {
        return getTimeboxEndFieldName();
    };

    this.getOidInfo = function(oid) {
        var idx = findOid(oid);
        if (idx >= 0) {
            return timeboxList[idx];
        } else {
            return [];
        }
    };

    //Return release name, start, end, and project for a release within a program
    this.getReleaseInfo = function(programName, releaseOid) {
        for (var i = 0; i < timeboxList.length; i++) {
            if (timeboxList[i].Name === programName) {
                for (j = 0; j < timeboxList[i].Releases.length; j++) {
                    if (timeboxList[i].Releases[j].ObjectID == releaseOid) {
                        return timeboxList[i].Releases[j];
                    }
                }
            }
        }
        return null;
    };

    return that;
};

</script>

<script type="text/javascript" description="User Settings">
    var WORKSPACE_OID = '__WORKSPACE_OID__';

    //  Top-level project to display
    var PROJECT_OID = '__PROJECT_OID__';

    // Comma-separated list of project OIDs, consisting of PROJECT_OID and all its children.
    var PROJECT_OIDS_IN_SCOPE = '__PROJECT_OIDS_IN_SCOPE__';

    var SCOPE_UP = '__PROJECT_SCOPING_UP__';
    var SCOPE_DOWN = '__PROJECT_SCOPING_DOWN__';
</script>

<script type="text/javascript" description="mashup constants">
    var MASHUP_TYPE = RALLY.Mashup.RELEASE;
    var TIMEBOX_TYPE = RALLY.Mashup.RELEASE;
    var SPECIAL_VERSION = false;
    var BURNDOWN_UNITS = 'todo';
    var CHART_WIDTH, WIDGET_MODE;
</script>

</head>
<body class="nihilo">
<div style="float:left" id="title" class="titlebar"></div>
<div id="helpAndActions">
    <div style="float:right" id="help"></div>
    <table>
        <tr>
            <td style="text-align: left; width: 99%;"></td>
            <td style="text-align: right; width: 1%;">
                <img id="do" onmouseover="RALLY.Mashup.Utilities.showcbButton();"
                     onmouseout="hidecbMenu('buttons',event);"
                     style="vertical-align: middle;"
                     src="/slm/images/menu_actions.gif"/>

                <div style="position:relative;top:5px" align="left">
                    <div id="buttons" class="do-menu" style="left:0px;"
                         onmouseover="document.body.style.cursor='pointer';"
                         onmouseout="document.body.style.cursor='default';hidecbMenu('buttons',event);">
                        <a id="print" onclick="RALLY.Mashup.Utilities.printPage();">Print...</a>
                    </div>
                </div>
            </td>
        </tr>
    </table>
</div>
<div style="clear:both"></div>
<div id='warning' class="dashboard-warning"></div>
<table>
    <tr>
        <td id="timeboxLabel" class="timeboxLabel">Timebox Name</td>
        <td><select id="timeboxList"></select></td>
    </tr>
</table>
<div id="spinner"></div>
<div id="legendDiv" class="dijitTitlePaneTitle">
    <div id="placeholder1" style="float:left"></div>
    <div id="placeholder2" style="float:left"></div>
    <div id="placeholder3" style="float:left"></div>
    <div style="clear:both"></div>
</div>
<div id="charts" class="dashboard-frame"></div>
</body>
</html>